"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

const _require = require(`child_process`),
      execSync = _require.execSync;

const execa = require(`execa`);

const hostedGitInfo = require(`hosted-git-info`);

const fs = require(`fs-extra`);

const sysPath = require(`path`);

const report = require(`./reporter`);

const url = require(`url`);

const isValid = require(`is-valid-path`);

const existsSync = require(`fs-exists-cached`).sync;

const _require2 = require(`gatsby-telemetry`),
      trackCli = _require2.trackCli,
      trackError = _require2.trackError;

const prompts = require(`prompts`);

const opn = require(`better-opn`);

const _require3 = require(`./util/configstore`),
      getPackageManager = _require3.getPackageManager,
      promptPackageManager = _require3.promptPackageManager;

const isTTY = require(`./util/is-tty`);

const spawn = (cmd, options) => {
  const _cmd$split = cmd.split(/\s+/),
        file = _cmd$split[0],
        args = _cmd$split.slice(1);

  return spawnWithArgs(file, args, options);
};

const spawnWithArgs = (file, args, options) => execa(file, args, Object.assign({
  stdio: `inherit`,
  preferLocal: false
}, options)); // Checks the existence of yarn package and user preference if it exists
// We use yarnpkg instead of yarn to avoid conflict with Hadoop yarn
// Refer to https://github.com/yarnpkg/yarn/issues/673


const shouldUseYarn =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(function* () {
    try {
      execSync(`yarnpkg --version`, {
        stdio: `ignore`
      });
      let packageManager = getPackageManager();

      if (!packageManager) {
        // if package manager is not set:
        //  - prompt user to pick package manager if in interactive console
        //  - default to yarn if not in interactive console
        if (isTTY()) {
          packageManager = (yield promptPackageManager()) || `yarn`;
        } else {
          packageManager = `yarn`;
        }
      }

      return packageManager === `yarn`;
    } catch (e) {
      return false;
    }
  });

  return function shouldUseYarn() {
    return _ref.apply(this, arguments);
  };
}();

const isAlreadyGitRepository =
/*#__PURE__*/
function () {
  var _ref2 = (0, _asyncToGenerator2.default)(function* () {
    try {
      return yield spawn(`git rev-parse --is-inside-work-tree`, {
        stdio: `pipe`
      }).then(output => output.stdout === `true`);
    } catch (err) {
      return false;
    }
  });

  return function isAlreadyGitRepository() {
    return _ref2.apply(this, arguments);
  };
}(); // Initialize newly cloned directory as a git repo


const gitInit =
/*#__PURE__*/
function () {
  var _ref3 = (0, _asyncToGenerator2.default)(function* (rootPath) {
    report.info(`Initialising git in ${rootPath}`);
    return yield spawn(`git init`, {
      cwd: rootPath
    });
  });

  return function gitInit(_x) {
    return _ref3.apply(this, arguments);
  };
}(); // Create a .gitignore file if it is missing in the new directory


const maybeCreateGitIgnore =
/*#__PURE__*/
function () {
  var _ref4 = (0, _asyncToGenerator2.default)(function* (rootPath) {
    if (existsSync(sysPath.join(rootPath, `.gitignore`))) {
      return;
    }

    report.info(`Creating minimal .gitignore in ${rootPath}`);
    yield fs.writeFile(sysPath.join(rootPath, `.gitignore`), `.cache\nnode_modules\npublic\n`);
  });

  return function maybeCreateGitIgnore(_x2) {
    return _ref4.apply(this, arguments);
  };
}(); // Create an initial git commit in the new directory


const createInitialGitCommit =
/*#__PURE__*/
function () {
  var _ref5 = (0, _asyncToGenerator2.default)(function* (rootPath, starterUrl) {
    report.info(`Create initial git commit in ${rootPath}`);
    yield spawn(`git add -A`, {
      cwd: rootPath
    }); // use execSync instead of spawn to handle git clients using
    // pgp signatures (with password)

    try {
      execSync(`git commit -m "Initial commit from gatsby: (${starterUrl})"`, {
        cwd: rootPath
      });
    } catch (_unused) {
      // Remove git support if intial commit fails
      report.info(`Initial git commit failed - removing git support\n`);
      fs.removeSync(sysPath.join(rootPath, `.git`));
    }
  });

  return function createInitialGitCommit(_x3, _x4) {
    return _ref5.apply(this, arguments);
  };
}(); // Executes `npm install` or `yarn install` in rootPath.


const install =
/*#__PURE__*/
function () {
  var _ref6 = (0, _asyncToGenerator2.default)(function* (rootPath) {
    const prevDir = process.cwd();
    report.info(`Installing packages...`);
    process.chdir(rootPath);

    try {
      if (yield shouldUseYarn()) {
        yield fs.remove(`package-lock.json`);
        yield spawn(`yarnpkg`);
      } else {
        yield fs.remove(`yarn.lock`);
        yield spawn(`npm install`);
      }
    } finally {
      process.chdir(prevDir);
    }
  });

  return function install(_x5) {
    return _ref6.apply(this, arguments);
  };
}();

const ignored = path => !/^\.(git|hg)$/.test(sysPath.basename(path)); // Copy starter from file system.


const copy =
/*#__PURE__*/
function () {
  var _ref7 = (0, _asyncToGenerator2.default)(function* (starterPath, rootPath) {
    // Chmod with 755.
    // 493 = parseInt('755', 8)
    yield fs.mkdirp(rootPath, {
      mode: 493
    });

    if (!existsSync(starterPath)) {
      throw new Error(`starter ${starterPath} doesn't exist`);
    }

    if (starterPath === `.`) {
      throw new Error(`You can't create a starter from the existing directory. If you want to
      create a new site in the current directory, the trailing dot isn't
      necessary. If you want to create a new site from a local starter, run
      something like "gatsby new new-gatsby-site ../my-gatsby-starter"`);
    }

    report.info(`Creating new site from local starter: ${starterPath}`);
    report.log(`Copying local starter to ${rootPath} ...`);
    yield fs.copy(starterPath, rootPath, {
      filter: ignored
    });
    report.success(`Created starter directory layout`);
    yield install(rootPath);
    return true;
  });

  return function copy(_x6, _x7) {
    return _ref7.apply(this, arguments);
  };
}(); // Clones starter from URI.


const clone =
/*#__PURE__*/
function () {
  var _ref8 = (0, _asyncToGenerator2.default)(function* (hostInfo, rootPath) {
    let url; // Let people use private repos accessed over SSH.

    if (hostInfo.getDefaultRepresentation() === `sshurl`) {
      url = hostInfo.ssh({
        noCommittish: true
      }); // Otherwise default to normal git syntax.
    } else {
      url = hostInfo.https({
        noCommittish: true,
        noGitPlus: true
      });
    }

    const branch = hostInfo.committish ? [`-b`, hostInfo.committish] : [];
    report.info(`Creating new site from git: ${url}`);
    const args = [`clone`, ...branch, url, rootPath, `--depth=1`].filter(arg => Boolean(arg));
    yield spawnWithArgs(`git`, args);
    report.success(`Created starter directory layout`);
    yield fs.remove(sysPath.join(rootPath, `.git`));
    yield install(rootPath);
    const isGit = yield isAlreadyGitRepository();
    if (!isGit) yield gitInit(rootPath);
    yield maybeCreateGitIgnore(rootPath);
    if (!isGit) yield createInitialGitCommit(rootPath, url);
  });

  return function clone(_x8, _x9) {
    return _ref8.apply(this, arguments);
  };
}();

const getPaths =
/*#__PURE__*/
function () {
  var _ref9 = (0, _asyncToGenerator2.default)(function* (starterPath, rootPath) {
    let selectedOtherStarter = false; // if no args are passed, prompt user for path and starter

    if (!starterPath && !rootPath) {
      const response = yield prompts.prompt([{
        type: `text`,
        name: `path`,
        message: `What is your project called?`,
        initial: `my-gatsby-project`
      }, {
        type: `select`,
        name: `starter`,
        message: `What starter would you like to use?`,
        choices: [{
          title: `gatsby-starter-default`,
          value: `gatsby-starter-default`
        }, {
          title: `gatsby-starter-hello-world`,
          value: `gatsby-starter-hello-world`
        }, {
          title: `gatsby-starter-blog`,
          value: `gatsby-starter-blog`
        }, {
          title: `(Use a different starter)`,
          value: `different`
        }],
        initial: 0
      }]); // exit gracefully if responses aren't provided

      if (!response.starter || !response.path.trim()) {
        throw new Error(`Please mention both starter package and project name along with path(if its not in the root)`);
      }

      selectedOtherStarter = response.starter === `different`;
      starterPath = `gatsbyjs/${response.starter}`;
      rootPath = response.path;
    } // set defaults if no root or starter has been set yet


    rootPath = rootPath || process.cwd();
    starterPath = starterPath || `gatsbyjs/gatsby-starter-default`;
    return {
      starterPath,
      rootPath,
      selectedOtherStarter
    };
  });

  return function getPaths(_x10, _x11) {
    return _ref9.apply(this, arguments);
  };
}();

const successMessage = path => {
  report.info(`
Your new Gatsby site has been successfully bootstrapped. Start developing it by running:

  cd ${path}
  gatsby develop
`);
};
/**
 * Main function that clones or copies the starter.
 */


module.exports =
/*#__PURE__*/
function () {
  var _ref10 = (0, _asyncToGenerator2.default)(function* (starter, options = {}) {
    const _ref11 = yield getPaths(starter, options.rootPath),
          starterPath = _ref11.starterPath,
          rootPath = _ref11.rootPath,
          selectedOtherStarter = _ref11.selectedOtherStarter;

    const urlObject = url.parse(rootPath);

    if (selectedOtherStarter) {
      report.info(`Opening the starter library at https://gatsby.dev/starters?v=2...\nThe starter library has a variety of options for starters you can browse\n\nYou can then use the gatsby new command with the link to a repository of a starter you'd like to use, for example:\ngatsby new ${rootPath} https://github.com/gatsbyjs/gatsby-starter-default`);
      opn(`https://gatsby.dev/starters?v=2`);
      return;
    }

    if (urlObject.protocol && urlObject.host) {
      trackError(`NEW_PROJECT_NAME_MISSING`);
      const isStarterAUrl = starter && !url.parse(starter).hostname && !url.parse(starter).protocol;

      if (/gatsby-starter/gi.test(rootPath) && isStarterAUrl) {
        report.panic({
          id: `11610`,
          context: {
            starter,
            rootPath
          }
        });
        return;
      }

      report.panic({
        id: `11611`,
        context: {
          rootPath
        }
      });
      return;
    }

    if (!isValid(rootPath)) {
      report.panic({
        id: `11612`,
        context: {
          path: sysPath.resolve(rootPath)
        }
      });
      return;
    }

    if (existsSync(sysPath.join(rootPath, `package.json`))) {
      trackError(`NEW_PROJECT_IS_NPM_PROJECT`);
      report.panic({
        id: `11613`,
        context: {
          rootPath
        }
      });
      return;
    }

    const hostedInfo = hostedGitInfo.fromUrl(starterPath);
    trackCli(`NEW_PROJECT`, {
      starterName: hostedInfo ? hostedInfo.shortcut() : `local:starter`
    });
    if (hostedInfo) yield clone(hostedInfo, rootPath);else yield copy(starterPath, rootPath);
    successMessage(rootPath);
    trackCli(`NEW_PROJECT_END`);
  });

  return function (_x12) {
    return _ref10.apply(this, arguments);
  };
}();