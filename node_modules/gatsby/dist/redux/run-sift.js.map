{"version":3,"sources":["../../src/redux/run-sift.js"],"names":["default","sift","require","_","prepareRegex","makeRe","getValueAt","toDottedFields","objectToDottedField","liftResolvedFields","prepareQueryArgs","filterFields","Object","keys","reduce","acc","key","value","isPlainObject","getFilters","filters","push","isEqId","siftArgs","length","id","handleFirst","nodes","index","isEmpty","findIndex","$and","handleMany","sort","resolvedFields","result","filter","dottedFields","dottedFieldKeys","sortFields","fields","map","field","some","startsWith","v","sortOrder","order","toLowerCase","orderBy","runSift","args","getNode","addResolvedNodes","getResolvedNode","nodeTypeNames","queryArgs","getOwnPropertyNames","eq","node","undefined","typeName","forEach","runSiftOnNodes","exports","firstOnly","siftFilter","$eq","internal","includes","type"],"mappings":"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","sourcesContent":["// @flow\nconst { default: sift } = require(`sift`)\nconst _ = require(`lodash`)\nconst prepareRegex = require(`../utils/prepare-regex`)\nconst { makeRe } = require(`micromatch`)\nconst { getValueAt } = require(`../utils/get-value-at`)\nconst {\n  toDottedFields,\n  objectToDottedField,\n  liftResolvedFields,\n} = require(`../db/common/query`)\n\n/////////////////////////////////////////////////////////////////////\n// Parse filter\n/////////////////////////////////////////////////////////////////////\n\nconst prepareQueryArgs = (filterFields = {}) =>\n  Object.keys(filterFields).reduce((acc, key) => {\n    const value = filterFields[key]\n    if (_.isPlainObject(value)) {\n      acc[key === `elemMatch` ? `$elemMatch` : key] = prepareQueryArgs(value)\n    } else {\n      switch (key) {\n        case `regex`:\n          acc[`$regex`] = prepareRegex(value)\n          break\n        case `glob`:\n          acc[`$regex`] = makeRe(value)\n          break\n        default:\n          acc[`$${key}`] = value\n      }\n    }\n    return acc\n  }, {})\n\nconst getFilters = filters =>\n  Object.keys(filters).reduce(\n    (acc, key) => acc.push({ [key]: filters[key] }) && acc,\n    []\n  )\n\n/////////////////////////////////////////////////////////////////////\n// Run Sift\n/////////////////////////////////////////////////////////////////////\n\nfunction isEqId(siftArgs) {\n  // The `id` of each node is invariably unique. So if a query is doing id $eq(string) it can find only one node tops\n  return (\n    siftArgs.length > 0 &&\n    siftArgs[0].id &&\n    Object.keys(siftArgs[0].id).length === 1 &&\n    Object.keys(siftArgs[0].id)[0] === `$eq`\n  )\n}\n\nfunction handleFirst(siftArgs, nodes) {\n  if (nodes.length === 0) {\n    return []\n  }\n\n  const index = _.isEmpty(siftArgs)\n    ? 0\n    : nodes.findIndex(\n        sift({\n          $and: siftArgs,\n        })\n      )\n\n  if (index !== -1) {\n    return [nodes[index]]\n  } else {\n    return []\n  }\n}\n\nfunction handleMany(siftArgs, nodes, sort, resolvedFields) {\n  let result = _.isEmpty(siftArgs)\n    ? nodes\n    : nodes.filter(\n        sift({\n          $and: siftArgs,\n        })\n      )\n\n  if (!result || !result.length) return null\n\n  // Sort results.\n  if (sort && result.length > 1) {\n    // create functions that return the item to compare on\n    const dottedFields = objectToDottedField(resolvedFields)\n    const dottedFieldKeys = Object.keys(dottedFields)\n    const sortFields = sort.fields\n      .map(field => {\n        if (\n          dottedFields[field] ||\n          dottedFieldKeys.some(key => field.startsWith(key))\n        ) {\n          return `__gatsby_resolved.${field}`\n        } else {\n          return field\n        }\n      })\n      .map(field => v => getValueAt(v, field))\n    const sortOrder = sort.order.map(order => order.toLowerCase())\n\n    result = _.orderBy(result, sortFields, sortOrder)\n  }\n  return result\n}\n\n/**\n * Filters a list of nodes using mongodb-like syntax.\n *\n * @param args raw graphql query filter as an object\n * @param nodes The nodes array to run sift over (Optional\n *   will load itself if not present)\n * @param type gqlType. Created in build-node-types\n * @param firstOnly true if you want to return only the first result\n *   found. This will return a collection of size 1. Not a single\n *   element\n * @returns Collection of results. Collection will be limited to size\n *   if `firstOnly` is true\n */\nconst runSift = (args: Object) => {\n  const { getNode, addResolvedNodes, getResolvedNode } = require(`./nodes`)\n\n  const { nodeTypeNames } = args\n  if (\n    args.queryArgs?.filter &&\n    Object.getOwnPropertyNames(args.queryArgs.filter).length === 1 &&\n    typeof args.queryArgs.filter?.id?.eq === `string`\n  ) {\n    // The args have an id.eq which subsumes all other queries\n    // Since the id of every node is unique there can only ever be one node found this way. Find it and return it.\n    let id = args.queryArgs.filter.id.eq\n    let node = undefined\n    nodeTypeNames.some(typeName => {\n      node = getResolvedNode(typeName, id)\n      return !!node\n    })\n    if (node) {\n      return [node]\n    }\n  }\n\n  let nodes = []\n\n  nodeTypeNames.forEach(typeName => addResolvedNodes(typeName, nodes))\n\n  return runSiftOnNodes(nodes, args, getNode)\n}\n\nexports.runSift = runSift\n\nconst runSiftOnNodes = (nodes, args, getNode) => {\n  const {\n    queryArgs = { filter: {}, sort: {} },\n    firstOnly = false,\n    resolvedFields = {},\n    nodeTypeNames,\n  } = args\n\n  let siftFilter = getFilters(\n    liftResolvedFields(\n      toDottedFields(prepareQueryArgs(queryArgs.filter)),\n      resolvedFields\n    )\n  )\n\n  // If the the query for single node only has a filter for an \"id\"\n  // using \"eq\" operator, then we'll just grab that ID and return it.\n  if (isEqId(siftFilter)) {\n    const node = getNode(siftFilter[0].id.$eq)\n\n    if (\n      !node ||\n      (node.internal && !nodeTypeNames.includes(node.internal.type))\n    ) {\n      if (firstOnly) return []\n      return null\n    }\n\n    return [node]\n  }\n\n  if (firstOnly) {\n    return handleFirst(siftFilter, nodes)\n  } else {\n    return handleMany(siftFilter, nodes, queryArgs.sort, resolvedFields)\n  }\n}\n\nexports.runSiftOnNodes = runSiftOnNodes\n"],"file":"run-sift.js"}