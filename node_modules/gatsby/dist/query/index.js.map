{"version":3,"sources":["../../src/query/index.js"],"names":["_","require","Queue","store","emitter","boundActionCreators","report","queryQueue","GraphQLRunner","seenIdsWithoutDataDependencies","Set","queuedDirtyActions","extractedQueryIds","on","action","delete","payload","path","push","popExtractedQueries","queries","clear","findIdsWithoutDataDependencies","state","allTrackedIds","boundAddToTrackedIds","add","bind","componentDataDependencies","nodes","forEach","dependenciesOnNode","connections","dependenciesOnConnection","notTrackedIds","Array","from","pages","values","p","staticQueryComponents","map","c","id","filter","x","has","notTrackedId","popNodeQueries","actions","uniq","a","uniqDirties","reduce","dirtyIds","node","internal","type","get","n","popNodeAndDepQueries","nodeQueries","noDepQueries","calcDirtyQueryIds","union","calcInitialDirtyQueryIds","nodeAndNoDepQueries","extractedQueriesThatNeedRunning","intersection","groupQueryIds","queryIds","grouped","groupBy","slice","staticQueryIds","static","pageQueryIds","page","processQueries","queryJobs","activity","queue","createBuildQueue","processBatch","createStaticQueryJob","queryId","component","hash","query","componentPath","context","createQueryRunningActivity","queryJobsCount","parentSpan","createProgress","start","done","completeActivity","tick","processStaticQueries","getState","processPageQueries","createPageQueryJob","getInitialQueryProcessors","queryjobsCount","length","processedQueuesCount","createProcessor","fn","initialProcessQueries","components","isPage","listenerQueue","runQueuedQueries","startListeningToDevelopQueue","graphqlRunner","developQueue","createDevelopQueue","callback","onFinish","arg","then","catch","pendingActivity","eventType","event","enqueueExtractedQueryId","pathname","getPagesForComponent","enqueueExtractedPageComponent","deleteComponentsDependencies","module","exports"],"mappings":"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","sourcesContent":["// @flow\n\nconst _ = require(`lodash`)\nconst Queue = require(`better-queue`)\n// const convertHrtime = require(`convert-hrtime`)\nconst { store, emitter } = require(`../redux`)\nconst { boundActionCreators } = require(`../redux/actions`)\nconst report = require(`gatsby-cli/lib/reporter`)\nconst queryQueue = require(`./queue`)\nconst GraphQLRunner = require(`./graphql-runner`)\n\nconst seenIdsWithoutDataDependencies = new Set()\nlet queuedDirtyActions = []\nconst extractedQueryIds = new Set()\n\n// Remove pages from seenIdsWithoutDataDependencies when they're deleted\n// so their query will be run again if they're created again.\nemitter.on(`DELETE_PAGE`, action => {\n  seenIdsWithoutDataDependencies.delete(action.payload.path)\n})\n\nemitter.on(`CREATE_NODE`, action => {\n  queuedDirtyActions.push(action)\n})\n\nemitter.on(`DELETE_NODE`, action => {\n  queuedDirtyActions.push({ payload: action.payload })\n})\n\n/////////////////////////////////////////////////////////////////////\n// Calculate dirty static/page queries\n\nconst popExtractedQueries = () => {\n  const queries = [...extractedQueryIds]\n  extractedQueryIds.clear()\n  return queries\n}\n\nconst findIdsWithoutDataDependencies = state => {\n  const allTrackedIds = new Set()\n  const boundAddToTrackedIds = allTrackedIds.add.bind(allTrackedIds)\n  state.componentDataDependencies.nodes.forEach(dependenciesOnNode => {\n    dependenciesOnNode.forEach(boundAddToTrackedIds)\n  })\n  state.componentDataDependencies.connections.forEach(\n    dependenciesOnConnection => {\n      dependenciesOnConnection.forEach(boundAddToTrackedIds)\n    }\n  )\n\n  // Get list of paths not already tracked and run the queries for these\n  // paths.\n  const notTrackedIds = new Set(\n    [\n      ...Array.from(state.pages.values(), p => p.path),\n      ...[...state.staticQueryComponents.values()].map(c => c.id),\n    ].filter(\n      x => !allTrackedIds.has(x) && !seenIdsWithoutDataDependencies.has(x)\n    )\n  )\n\n  // Add new IDs to our seen array so we don't keep trying to run queries for them.\n  // Pages without queries can't be tracked.\n  for (const notTrackedId of notTrackedIds) {\n    seenIdsWithoutDataDependencies.add(notTrackedId)\n  }\n\n  return notTrackedIds\n}\n\nconst popNodeQueries = state => {\n  const actions = _.uniq(queuedDirtyActions, a => a.payload.id)\n  const uniqDirties = actions.reduce((dirtyIds, action) => {\n    const node = action.payload\n\n    if (!node || !node.id || !node.internal.type) return dirtyIds\n\n    // Find components that depend on this node so are now dirty.\n    if (state.componentDataDependencies.nodes.has(node.id)) {\n      state.componentDataDependencies.nodes.get(node.id).forEach(n => {\n        if (n) {\n          dirtyIds.add(n)\n        }\n      })\n    }\n\n    // Find connections that depend on this node so are now invalid.\n    if (state.componentDataDependencies.connections.has(node.internal.type)) {\n      state.componentDataDependencies.connections\n        .get(node.internal.type)\n        .forEach(n => {\n          if (n) {\n            dirtyIds.add(n)\n          }\n        })\n    }\n\n    return dirtyIds\n  }, new Set())\n  queuedDirtyActions = []\n  return uniqDirties\n}\n\nconst popNodeAndDepQueries = state => {\n  const nodeQueries = popNodeQueries(state)\n\n  const noDepQueries = findIdsWithoutDataDependencies(state)\n\n  return _.uniq([...nodeQueries, ...noDepQueries])\n}\n\n/**\n * Calculates the set of dirty query IDs (page.paths, or\n * staticQuery.hash's). These are queries that:\n *\n * - depend on nodes or node collections (via\n *   `actions.createPageDependency`) that have changed.\n * - do NOT have node dependencies. Since all queries should return\n *   data, then this implies that node dependencies have not been\n *   tracked, and therefore these queries haven't been run before\n * - have been recently extracted (see `./query-watcher.js`)\n *\n * Note, this function pops queries off internal queues, so it's up\n * to the caller to reference the results\n */\n\nconst calcDirtyQueryIds = state =>\n  _.union(popNodeAndDepQueries(state), popExtractedQueries())\n\n/**\n * Same as `calcDirtyQueryIds`, except that we only include extracted\n * queries that depend on nodes or haven't been run yet. We do this\n * because the page component reducer/machine always enqueues\n * extractedQueryIds but during bootstrap we may not want to run those\n * page queries if their data hasn't changed since the last time we\n * ran Gatsby.\n */\nconst calcInitialDirtyQueryIds = state => {\n  const nodeAndNoDepQueries = popNodeAndDepQueries(state)\n\n  const extractedQueriesThatNeedRunning = _.intersection(\n    popExtractedQueries(),\n    nodeAndNoDepQueries\n  )\n  return _.union(extractedQueriesThatNeedRunning, nodeAndNoDepQueries)\n}\n\n/**\n * groups queryIds by whether they are static or page queries.\n */\nconst groupQueryIds = queryIds => {\n  const grouped = _.groupBy(queryIds, p =>\n    p.slice(0, 4) === `sq--` ? `static` : `page`\n  )\n  return {\n    staticQueryIds: grouped.static || [],\n    pageQueryIds: grouped.page || [],\n  }\n}\n\nconst processQueries = async (queryJobs, activity) => {\n  const queue = queryQueue.createBuildQueue()\n  await queryQueue.processBatch(queue, queryJobs, activity)\n}\n\nconst createStaticQueryJob = (state, queryId) => {\n  const component = state.staticQueryComponents.get(queryId)\n  const { hash, id, query, componentPath } = component\n  return {\n    id: hash,\n    hash,\n    query,\n    componentPath,\n    context: { path: id },\n  }\n}\n\n/**\n * Creates activity object which:\n *  - creates actual progress activity if there are any queries that need to be run\n *  - creates activity-like object that just cancels pending activity if there are no queries to run\n */\nconst createQueryRunningActivity = (queryJobsCount, parentSpan) => {\n  if (queryJobsCount) {\n    const activity = report.createProgress(`run queries`, queryJobsCount, 0, {\n      id: `query-running`,\n      parentSpan,\n    })\n    activity.start()\n    return activity\n  } else {\n    return {\n      done: () => {\n        report.completeActivity(`query-running`)\n      },\n      tick: () => {},\n    }\n  }\n}\n\nconst processStaticQueries = async (queryIds, { state, activity }) => {\n  state = state || store.getState()\n  await processQueries(\n    queryIds.map(id => createStaticQueryJob(state, id)),\n    activity\n  )\n}\n\nconst processPageQueries = async (queryIds, { state, activity }) => {\n  state = state || store.getState()\n  // Make sure we filter out pages that don't exist. An example is\n  // /dev-404-page/, whose SitePage node is created via\n  // `internal-data-bridge`, but the actual page object is only\n  // created during `gatsby develop`.\n  const pages = _.filter(queryIds.map(id => state.pages.get(id)))\n  await processQueries(\n    pages.map(page => createPageQueryJob(state, page)),\n    activity\n  )\n}\n\nconst getInitialQueryProcessors = ({ parentSpan } = {}) => {\n  const state = store.getState()\n  const queryIds = calcInitialDirtyQueryIds(state)\n  const { staticQueryIds, pageQueryIds } = groupQueryIds(queryIds)\n\n  const queryjobsCount =\n    _.filter(pageQueryIds.map(id => state.pages.get(id))).length +\n    staticQueryIds.length\n\n  let activity = null\n  let processedQueuesCount = 0\n  const createProcessor = (fn, queryIds) => async () => {\n    if (!activity) {\n      activity = createQueryRunningActivity(queryjobsCount, parentSpan)\n    }\n\n    await fn(queryIds, { state, activity })\n\n    processedQueuesCount++\n    // if both page and static queries are done, finish activity\n    if (processedQueuesCount === 2) {\n      activity.done()\n    }\n  }\n\n  return {\n    processStaticQueries: createProcessor(processStaticQueries, staticQueryIds),\n    processPageQueries: createProcessor(processPageQueries, pageQueryIds),\n    pageQueryIds,\n  }\n}\n\nconst initialProcessQueries = async ({ parentSpan } = {}) => {\n  const {\n    pageQueryIds,\n    processPageQueries,\n    processStaticQueries,\n  } = getInitialQueryProcessors({ parentSpan })\n\n  await processStaticQueries()\n  await processPageQueries()\n\n  return { pageQueryIds }\n}\n\nconst createPageQueryJob = (state, page) => {\n  const component = state.components.get(page.componentPath)\n  const { path, componentPath, context } = page\n  const { query } = component\n  return {\n    id: path,\n    query,\n    isPage: true,\n    componentPath,\n    context: {\n      ...page,\n      ...context,\n    },\n  }\n}\n\n/////////////////////////////////////////////////////////////////////\n// Listener for gatsby develop\n\n// Initialized via `startListening`\nlet listenerQueue\n\n/**\n * Run any dirty queries. See `calcQueries` for what constitutes a\n * dirty query\n */\nconst runQueuedQueries = () => {\n  if (listenerQueue) {\n    const state = store.getState()\n    const { staticQueryIds, pageQueryIds } = groupQueryIds(\n      calcDirtyQueryIds(state)\n    )\n    const pages = _.filter(pageQueryIds.map(id => state.pages.get(id)))\n    const queryJobs = [\n      ...staticQueryIds.map(id => createStaticQueryJob(state, id)),\n      ...pages.map(page => createPageQueryJob(state, page)),\n    ]\n    listenerQueue.push(queryJobs)\n  }\n}\n\n/**\n * Starts a background process that processes any dirty queries\n * whenever one of the following occurs:\n *\n * 1. A node has changed (but only after the api call has finished\n * running)\n * 2. A component query (e.g. by editing a React Component) has\n * changed\n *\n * For what constitutes a dirty query, see `calcQueries`\n */\n\nconst startListeningToDevelopQueue = () => {\n  // We use a queue to process batches of queries so that they are\n  // processed consecutively\n  let graphqlRunner = null\n  const developQueue = queryQueue.createDevelopQueue(() => {\n    if (!graphqlRunner) {\n      graphqlRunner = new GraphQLRunner(store)\n    }\n    return graphqlRunner\n  })\n  listenerQueue = new Queue((queryJobs, callback) => {\n    const activity = createQueryRunningActivity(queryJobs.length)\n\n    const onFinish = (...arg) => {\n      activity.done()\n      return callback(...arg)\n    }\n\n    return queryQueue\n      .processBatch(developQueue, queryJobs, activity)\n      .then(() => onFinish(null))\n      .catch(onFinish)\n  })\n\n  emitter.on(`API_RUNNING_START`, () => {\n    report.pendingActivity({ id: `query-running` })\n  })\n\n  emitter.on(`API_RUNNING_QUEUE_EMPTY`, runQueuedQueries)\n  ;[\n    `DELETE_CACHE`,\n    `CREATE_NODE`,\n    `DELETE_NODE`,\n    `DELETE_NODES`,\n    `SET_SCHEMA_COMPOSER`,\n    `SET_SCHEMA`,\n    `ADD_FIELD_TO_NODE`,\n    `ADD_CHILD_NODE_TO_PARENT_NODE`,\n  ].forEach(eventType => {\n    emitter.on(eventType, event => {\n      graphqlRunner = null\n    })\n  })\n}\n\nconst enqueueExtractedQueryId = pathname => {\n  extractedQueryIds.add(pathname)\n}\n\nconst getPagesForComponent = componentPath => {\n  const state = store.getState()\n  return [...state.pages.values()].filter(\n    p => p.componentPath === componentPath\n  )\n}\n\nconst enqueueExtractedPageComponent = componentPath => {\n  const pages = getPagesForComponent(componentPath)\n  // Remove page data dependencies before re-running queries because\n  // the changing of the query could have changed the data dependencies.\n  // Re-running the queries will add back data dependencies.\n  boundActionCreators.deleteComponentsDependencies(\n    pages.map(p => p.path || p.id)\n  )\n  pages.forEach(page => enqueueExtractedQueryId(page.path))\n  runQueuedQueries()\n}\n\nmodule.exports = {\n  calcInitialDirtyQueryIds,\n  processPageQueries,\n  processStaticQueries,\n  groupQueryIds,\n  initialProcessQueries,\n  getInitialQueryProcessors,\n  startListeningToDevelopQueue,\n  runQueuedQueries,\n  enqueueExtractedQueryId,\n  enqueueExtractedPageComponent,\n}\n"],"file":"index.js"}