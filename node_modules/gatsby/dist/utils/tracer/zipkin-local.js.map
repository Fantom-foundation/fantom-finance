{"version":3,"sources":["../../../src/utils/tracer/zipkin-local.js"],"names":["zipkin","require","HttpLogger","ZipkinTracer","fetch","logger","recorder","create","endpoint","BatchRecorder","timeout","tracer","localServiceName","serviceName","sampler","CountingSampler","traceId128Bit","kind","stop","partialSpans","forEach","span","id","_timedOut","_writeSpan","_processQueue","self","queue","length","postBody","join","method","body","headers","then","response","status","err","errorListenerSet","emit","Error","console","error","catch","module","exports"],"mappings":"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","sourcesContent":["const zipkin = require(`zipkin`)\nconst { HttpLogger } = require(`zipkin-transport-http`)\nconst ZipkinTracer = require(`zipkin-javascript-opentracing`)\nconst fetch = require(`node-fetch`)\n\nlet logger\nlet recorder\n\n/**\n * Create and return an open-tracing compatible tracer. See\n * https://github.com/opentracing/opentracing-javascript/blob/master/src/tracer.ts\n */\nfunction create() {\n  logger = new HttpLogger({\n    // endpoint of local docker zipkin instance\n    endpoint: `http://localhost:9411/api/v1/spans`,\n  })\n\n  recorder = new zipkin.BatchRecorder({\n    logger,\n    // timeout = 60 hours, must be longer than site's build time\n    timeout: 60 * 60 * 60 * 1000000,\n  })\n\n  const tracer = new ZipkinTracer({\n    localServiceName: `gatsby`,\n    serviceName: `gatsby`,\n    // Sample 1 out of 1 spans (100%). When tracing production\n    // services, it is normal to sample 1 out of 10 requests so that\n    // tracing information doesn't impact site performance. But Gatsby\n    // is a build tool and only has \"1\" request (the\n    // build). Therefore, we must set this to 100% so that spans\n    // aren't missing\n    sampler: new zipkin.sampler.CountingSampler(1),\n    traceId128Bit: true,\n    recorder,\n    kind: `client`,\n  })\n\n  return tracer\n}\n\n/**\n * Run any tracer cleanup required before the node.js process\n * exits. For Zipkin HTTP, we must manually process any spans still on\n * the queue\n */\nasync function stop() {\n  // First, write all partial spans to the http logger\n  recorder.partialSpans.forEach((span, id) => {\n    if (recorder._timedOut(span)) {\n      recorder._writeSpan(id)\n    }\n  })\n\n  // Then tell http logger to process all spans in its queue\n  return await _processQueue()\n}\n\n// Workaround for issue in Zipkin HTTP Logger where Spans are not\n// cleared off their processing queue before the node.js process\n// exits. Code is mostly the same as the zipkin processQueue\n// implementation.\nasync function _processQueue() {\n  const self = logger\n  if (self.queue.length > 0) {\n    const postBody = `[${self.queue.join(`,`)}]`\n    return await fetch(self.endpoint, {\n      method: `POST`,\n      body: postBody,\n      headers: self.headers,\n      timeout: self.timeout,\n    })\n      .then(response => {\n        if (response.status !== 202) {\n          const err =\n            `Unexpected response while sending Zipkin data, status:` +\n            `${response.status}, body: ${postBody}`\n\n          if (self.errorListenerSet) self.emit(`error`, new Error(err))\n          else console.error(err)\n        }\n      })\n      .catch(error => {\n        const err = `Error sending Zipkin data ${error}`\n        if (self.errorListenerSet) this.emit(`error`, new Error(err))\n        else console.error(err)\n      })\n  }\n  return true\n}\n\nmodule.exports = {\n  create,\n  stop,\n}\n"],"file":"zipkin-local.js"}